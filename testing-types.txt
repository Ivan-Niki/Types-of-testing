
=========== Классификация по запуску кода на исполнение ===========

Далеко не всякое тестирование предполагает взаимодействие с работающим приложением. Потому в рамках данной 
классификации выделяют два типа тестирования: 
1) статическое тестирование;
2) динамической тестирование.

Статическое тестирование (static testing) — тестирование без запуска кода на исполнение. 
В рамках этого подхода тестированию могут подвергаться:
- Документы (требования, тест-кейсы, описания архитектуры приложения, схемы баз данных и т.д.).
- Графические прототипы (например, эскизы пользовательского интерфейса).
- Код приложения (что часто выполняется самими программистами в рамках аудита кода (code review), являющегося 
специфической вариацией взаимного просмотра в применении к исходному коду). Код приложения также можно проверять с использованием техник тестирования на основе структур кода.
- Параметры (настройки) среды исполнения приложения.
- Подготовленные тестовые данные.

Динамическое тестирование (dynamic testing) — тестирование с запуском кода на исполнение.
Запускаться на исполнение может как код всего прило-жения целиком (системное тестирование), так и код нескольких 
взаимосвязанных частей (интеграционное тестирование), отдельных частей (модульное или компонентное тестирование) 
и даже отдельные участки кода. Основная идея этого вида тестирования состоит в том, что проверяется реальное 
поведение (части) приложения.


=========== Классификация по доступу к коду и архитектуре приложения ===========

Метод белого ящика (white box testing, open box testing, clear box testing, glass box testing) — у тестировщика 
есть доступ к внутренней структуре и коду приложения, а также есть достаточно знаний для понимания увиденного.

Метод чёрного ящика (black box testing, closed box testing, specification-based testing) — у тестировщика 
либо нет доступа к внутренней структуре и коду приложения, либо недостаточно знаний для их понимания, либо он 
сознательно не обращается к ним в процессе тестирования.
Основную суть метода чёрного ящика в альтернативном определении можно сформулировать так: тестировщик оказывает 
на приложение воздействия (и проверяет реакцию) тем же способом, каким при реальной эксплуатации приложения на 
него воздействовали бы пользователи или другие приложения.


=========== Классификация по степени автоматизации ===========

- Ручное тестирование (manual testing) — тестирование, в котором тест-кейсы выполняются человеком вручную без 
использования средств автоматизации.

- Автоматизированное тестирование (automated testing, test automation) — набор техник, подходов и 
инструментальных средств, позволяющий исключить человека из выполнения некоторых задач в процессе тестирования. 
Тест-кейсы частично или полностью выполняет специальное инструментальное средство, однако разработка 
тест-кейсов, подготовка данных, оценка результатов выполнения, написания отчётов об обнаруженных дефектах — всё 
это и многое другое по-прежнему делает человек.


=========== Классификация по уровню детализации приложения (по уровню тестирования) ===========

-> Модульное (компонентное) тестирование (unit testing, module testing, com-ponent testing) направлено на проверку 
отдельных небольших частей приложения, которые (как правило) можно исследовать изолированно от других подобных 
частей. При выполнении данного тестирования могут проверяться отдельные функции или методы классов, сами классы, 
взаимодействие классов, небольшие библиотеки, отдельные части приложения.
Часто данный вид тестирования реализуется с использованием специальных технологий и инструментальных средств 
автоматизации тестирования, значительно упрощающих и ускоряющих разработку соответствующих тест-кейсов.

-> Интеграционное тестирование (integration testing, component integration testing, system integration testing, 
incremental testing, interface testing, thread testing) направлено на проверку взаимодействия между несколькими 
частями приложения (каждая из которых, в свою очередь, проверена отдельно на стадии модульного тестирования).
К сожалению, даже если мы работаем с очень качественными отдельными компонентами, «на стыке» их взаимодействия 
часто возникают проблемы. Именно эти проблемы и выявляет интеграционное тестирование. (См. также техники 
восходящего, нисходящего и гибридного тестирования в хронологической классификации по иерархии компонентов.)

-> Системное тестирование (system testing) направлено на проверку всего приложения как единого целого, 
собранного из частей, проверенных на двух предыдущих стадиях. Здесь не только выявляются дефекты «на стыках» 
компонентов, но и появляется возможность полноценно взаимодействовать с приложением с точки зрения конечного 
пользователя, применяя множество других видов тестирования, перечисленных в данной главе.

Если обратиться к словарю ISTQB и прочитать определение уровня тестирования (test level), то можно увидеть, что аналогичное разбиение на модульное, интеграционное и системное тестирование, к которым добавлено ещё и 
приёмочное тестирование, используется в контексте разделения областей ответственности на проекте. 
Но такая классификация больше относится к вопросам управления проектом, чем к тестированию в чистом виде, а 
потому выходит за рамки рассматриваемых нами вопросов.


============ Классификация по степени важности тестируемых функций =============
В некоторых источниках эту разновидность классификации также называют «по глубине тестирования».

Дымовое тестирование (smoke test, intake test, build verification test) направлено на проверку самой главной, 
самой важной, самой ключевой функциональности, неработоспособность которой делает бессмысленной саму идею 
использования приложения (или иного объекта, подвергаемого дымовому тестированию).
Дымовое тестирование проводится после выхода нового билда, чтобы определить общий уровень качества приложения и 
принять решение о (не)целесообразности выполнения тестирования критического пути и расширенного тестирования. 
Поскольку тест-кейсов на уровне дымового тестирования относительно немного, а сами они достаточно просты, но 
при этом очень часто повторяются, они являются хорошими кандидатами на автоматизацию. 
В связи с высокой важностью тест-кейсов на данном уровне пороговое значение метрики их прохождения часто 
выставляется равным 100% или близким к 100%.

