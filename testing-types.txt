
=========== Классификация по запуску кода на исполнение ===========

Далеко не всякое тестирование предполагает взаимодействие с работающим приложением. Потому в рамках данной 
классификации выделяют два типа тестирования: 
1) статическое тестирование;
2) динамической тестирование.

Статическое тестирование (static testing) — тестирование без запуска кода на исполнение. 
В рамках этого подхода тестированию могут подвергаться:
- Документы (требования, тест-кейсы, описания архитектуры приложения, схемы баз данных и т.д.).
- Графические прототипы (например, эскизы пользовательского интерфейса).
- Код приложения (что часто выполняется самими программистами в рамках аудита кода (code review), являющегося 
специфической вариацией взаимного просмотра в применении к исходному коду). Код приложения также можно проверять с использованием техник тестирования на основе структур кода.
- Параметры (настройки) среды исполнения приложения.
- Подготовленные тестовые данные.

Динамическое тестирование (dynamic testing) — тестирование с запуском кода на исполнение.
Запускаться на исполнение может как код всего прило-жения целиком (системное тестирование), так и код нескольких 
взаимосвязанных частей (интеграционное тестирование), отдельных частей (модульное или компонентное тестирование) 
и даже отдельные участки кода. Основная идея этого вида тестирования состоит в том, что проверяется реальное 
поведение (части) приложения.


=========== Классификация по доступу к коду и архитектуре приложения ===========

Метод белого ящика (white box testing, open box testing, clear box testing, glass box testing) — у тестировщика 
есть доступ к внутренней структуре и коду приложения, а также есть достаточно знаний для понимания увиденного.

Метод чёрного ящика (black box testing, closed box testing, specification-based testing) — у тестировщика 
либо нет доступа к внутренней структуре и коду приложения, либо недостаточно знаний для их понимания, либо он 
сознательно не обращается к ним в процессе тестирования.
Основную суть метода чёрного ящика в альтернативном определении можно сформулировать так: тестировщик оказывает 
на приложение воздействия (и проверяет реакцию) тем же способом, каким при реальной эксплуатации приложения на 
него воздействовали бы пользователи или другие приложения.


=========== Классификация по степени автоматизации ===========

- Ручное тестирование (manual testing) — тестирование, в котором тест-кейсы выполняются человеком вручную без 
использования средств автоматизации.

- Автоматизированное тестирование (automated testing, test automation) — набор техник, подходов и 
инструментальных средств, позволяющий исключить человека из выполнения некоторых задач в процессе тестирования. 
Тест-кейсы частично или полностью выполняет специальное инструментальное средство, однако разработка 
тест-кейсов, подготовка данных, оценка результатов выполнения, написания отчётов об обнаруженных дефектах — всё 
это и многое другое по-прежнему делает человек.


=========== Классификация по уровню детализации приложения (по уровню тестирования) ===========

-> Модульное (компонентное) тестирование (unit testing, module testing, com-ponent testing) направлено на проверку 
отдельных небольших частей приложения, которые (как правило) можно исследовать изолированно от других подобных 
частей. При выполнении данного тестирования могут проверяться отдельные функции или методы классов, сами классы, 
взаимодействие классов, небольшие библиотеки, отдельные части приложения.
Часто данный вид тестирования реализуется с использованием специальных технологий и инструментальных средств 
автоматизации тестирования, значительно упрощающих и ускоряющих разработку соответствующих тест-кейсов.

-> Интеграционное тестирование (integration testing, component integration testing, system integration testing, 
incremental testing, interface testing, thread testing) направлено на проверку взаимодействия между несколькими 
частями приложения (каждая из которых, в свою очередь, проверена отдельно на стадии модульного тестирования).
К сожалению, даже если мы работаем с очень качественными отдельными компонентами, «на стыке» их взаимодействия 
часто возникают проблемы. Именно эти проблемы и выявляет интеграционное тестирование. (См. также техники 
восходящего, нисходящего и гибридного тестирования в хронологической классификации по иерархии компонентов.)

-> Системное тестирование (system testing) направлено на проверку всего приложения как единого целого, 
собранного из частей, проверенных на двух предыдущих стадиях. Здесь не только выявляются дефекты «на стыках» 
компонентов, но и появляется возможность полноценно взаимодействовать с приложением с точки зрения конечного 
пользователя, применяя множество других видов тестирования, перечисленных в данной главе.

Если обратиться к словарю ISTQB и прочитать определение уровня тестирования (test level), то можно увидеть, что аналогичное разбиение на модульное, интеграционное и системное тестирование, к которым добавлено ещё и 
приёмочное тестирование, используется в контексте разделения областей ответственности на проекте. 
Но такая классификация больше относится к вопросам управления проектом, чем к тестированию в чистом виде, а 
потому выходит за рамки рассматриваемых нами вопросов.


============ Классификация по степени важности тестируемых функций =============
В некоторых источниках эту разновидность классификации также называют «по глубине тестирования».

-> Дымовое тестирование (smoke test, intake test, build verification test) направлено на проверку самой главной, 
самой важной, самой ключевой функциональности, неработоспособность которой делает бессмысленной саму идею 
использования приложения (или иного объекта, подвергаемого дымовому тестированию).
Дымовое тестирование проводится после выхода нового билда, чтобы определить общий уровень качества приложения и 
принять решение о (не)целесообразности выполнения тестирования критического пути и расширенного тестирования. 
Поскольку тест-кейсов на уровне дымового тестирования относительно немного, а сами они достаточно просты, но 
при этом очень часто повторяются, они являются хорошими кандидатами на автоматизацию. 
В связи с высокой важностью тест-кейсов на данном уровне пороговое значение метрики их прохождения часто 
выставляется равным 100% или близким к 100%.

-> Тестирование критического пути (critical path test) направлено на исследование функциональности, используемой 
типичными пользователями в типичной повседневной деятельности. 
Идея заключается в следующем: существует большинство пользователей, которые чаще всего используют некое 
подмножество функций приложения. Именно эти функции и нужно проверить, как только мы убедились, что приложение 
«в принципе работает» (дымовой тест прошёл успешно). Если по каким-то причинам приложение не выполняет эти 
функции или выполняет их некорректно, очень многие пользователи не смогут достичь множества своих целей.
Пороговое значение метрики успешного прохождения «теста критического пути» уже немного ниже, чем в дымовом 
тестировании, но всё равно достаточно высоко (как правило, порядка 70–80–90% — в зависимости от сути проекта).

-> Расширенное тестирование (extended test) направлено на исследование всей заявленной в требованиях 
функциональности — даже той, которая низко проранжирована по степени важности.
При этом здесь также учитывается, какая функциональность является более важной, а какая — менее важной. Но при 
наличии достаточного количества времени и иных ресурсов тест-кейсы этого уровня могут затронуть даже самые 
низкоприоритетные требования.
Ещё одним направлением исследования в рамках данного тестирования являются нетипичные, маловероятные, 
экзотические случаи и сценарии использования функций и свойств приложения, затронутых на предыдущих уровнях. 
Пороговое значение метрики успешного прохождения расширенного тестирования существенно ниже, чем в тестировании 
критического пути (иногда можно увидеть даже значения в диапазоне 30–50%, т.к. подавляющее большинство 
найденных здесь дефектов не представляет угрозы для успешного использования приложения большинством пользователей).


============ Классификация по принципам работы с приложением =============

-> Позитивное тестирование (positive testing) направлено на исследование приложения в ситуации, когда все действия 
выполняются строго по инструкции без каких бы то ни было ошибок, отклонений, ввода неверных данных и т.д.
Если позитивные тест-кейсы завершаются ошибками, это тревожный признак — приложение работает неверно даже в 
идеальных условиях (и можно предположить, что в неидеальных условиях оно работает ещё хуже). Для ускорения 
тестирования несколько позитивных тест-кейсов можно объединять (например, перед отправкой заполнить все поля 
формы верными значениями) — иногда это может усложнить диагностику ошибки, но существенная экономия времени 
компенсирует этот риск.

-> Негативное тестирование (negative testing, invalid testing) — направлено на исследование работы приложения в 
ситуациях, когда с ним выполняются (некорректные) операции и/или используются данные, потенциально приводящие к 
ошибкам (классика жанра — деление на ноль).
Поскольку в реальной жизни таких ситуаций значительно больше (пользователи допускают ошибки, злоумышленники 
осознанно «ломают» приложение, в среде работы приложения возникают проблемы и т.д.), негативных тест-кейсов 
оказывается значительно больше, чем позитивных (иногда — в разы или даже на порядки). В отличие от позитивных 
негативные тест-кейсы НЕ стоит объединять, т.к. подобное решение может привести к неверной трактовке поведения 
приложения и пропуску (необнаружению) дефектов.


============ Классификация по привлечению конечных пользователей ============ 

-> Альфа-тестирование (alpha testing) выполняется внутри организации-разработчика с возможным частичным 
привлечением конечных пользователей. Может являться формой внутреннего приёмочного тестирования.
Может являться формой внутреннего приёмочного тестирования.
Суть этого вида вкратце: продукт уже можно периодически показывать внешним пользователям, но он ещё достаточно 
«сырой», потому основное тестирование выполняется организацией-разработчиком.

-> Бета-тестирование (beta testing) выполняется вне организации-разработчика с активным привлечением конечных 
пользователей/заказчиков. Может являться формой внешнего приёмочного тестирования.
Суть этого вида вкратце: продукт уже можно открыто показывать внешним пользователям, он уже достаточно стабилен, 
но проблемы всё ещё могут быть, и для их выявления нужна обратная связь от реальных пользователей.

-> Гамма-тестирование (gamma testing) — финальная стадия тестирования перед выпуском продукта, направленная на 
исправление незначительных дефектов, обнаруженных в бета-тестировании. Как правило, также выполняется с 
максимальным привлечением конечных пользователей/заказчиков. Может являться формой внешнего приёмочного 
тестирования. Суть этого вида вкратце: продукт уже почти готов, и сейчас обратная связь от реальных 
пользователей используется для устранения последних недоработок.


============ Классификация по степени формализации ============

-> Тестирование на основе тест-кейсов (scripted testing, test case based testing) — формализованный подход, в 
котором тестирование производится на основе заранее подготовленных тест-кейсов, наборов тест-кейсов и иной 
документации. Это самый распространённый способ тестирования, который также позволяет достичь максимальной 
полноты исследования приложения за счёт строгой систематизации процесса, удобства применения метрик и широкого 
набора выработанных за десятилетия и проверенных на практике рекомендаций.

-> Исследовательское тестирование (exploratory testing) — частично формализованный подход, в рамках которого тестировщик выполняет работу с приложением по выбранному сценарию, который, в свою очередь, дорабатывается в 
процессе выполнения с целью более полного исследования приложения.
Ключевым фактором успеха при выполнении исследовательского тестирования является именно работа по сценарию, а не 
выполнение разрозненных бездумных операций. Существует даже специальный сценарный подход, называемый сессионным 
тестированием (session-based testing). В качестве альтернативы сценариям при выборе действий с приложением 
иногда могут использоваться чек-листы, и тогда этот вид тестирования называют тестированием на основе чек-листов (checklist-based testing).

-> Свободное (интуитивное) тестирование (ad hoc testing) — полностью неформализованный подход, в котором не 
предполагается использования ни тест-кейсов, ни чек-листов, ни сценариев — тестировщик полностью опирается на 
свой профессионализм и интуицию (experience-based testing) для спонтанного выполнения с приложением действий, 
которые, как он считает, могут обнаружить ошибку.
Этот вид тестирования используется редко и исключительно как дополнение к полностью или частично 
формализованному тестированию в случаях, когда для исследования некоторого аспекта поведения приложения (пока?) 
нет тест-кейсов.



============ Классификация по целям и задачам ============

-> Позитивное тестирование (рассмотрено ранее).
-> Негативное тестирование (рассмотрено ранее).

-> Функциональное тестирование (functional testing) — вид тестирования, направленный на проверку корректности 
работы функциональности приложения (корректность реализации функциональных требований).
Часто функциональное тестирование ассоциируют с тестированием по методу чёрного ящика, однако и по методу белого 
ящика вполне можно проверять корректность реализации функциональности.

-> Нефункциональное тестирование (non-functional testing) — вид тестирования, направленный на проверку 
нефункциональных особенностей приложения (корректность реализации нефункциональных требований), таких как 
удобство использования, совместимость, производительность, безопасность и т.д.

-> Инсталляционное тестирование (installation testing, installability testing) — тестирование, направленное на 
выявление дефектов, влияющих на протекание стадии инсталляции (установки) приложения.
В общем случае такое тестирование проверяет множество сценариев и аспектов работы инсталлятора в таких ситуациях, как:
- новая среда исполнения, в которой приложение ранее не было инстал-лировано;
- обновление существующей версии («апгрейд»);
- изменение текущей версии на более старую («даунгрейд»);
- повторная установка приложения с целью устранения возникших проблем («переинсталляция»);
- повторный запуск инсталляции после ошибки, приведшей к невозможности продолжения инсталляции;
- удаление приложения;
- установка нового приложения из семейства приложений;
- автоматическая инсталляция без участия пользователя.

